{"uid":"d251892b8b34eba6","name":"test_app_names_match","fullName":"tests.test_data_in_tables#test_app_names_match","historyId":"97c2d95125bc8f15c7597d47dbe4f429","time":{"start":1712509335342,"stop":1712509336384,"duration":1042},"description":"\nТест проверяет, что для всех app_name из таблицы app_names существует соответствие с app_short в таблице device_segments. Это гарантирует целостность данных между таблицами и правильность ссылок на приложения.\n","descriptionHtml":"<p>Тест проверяет, что для всех app_name из таблицы app_names существует соответствие с app_short в таблице device_segments. Это гарантирует целостность данных между таблицами и правильность ссылок на приложения.</p>\n","status":"failed","statusMessage":"AssertionError: Найдены приложения в app_names без соответствия в device_segments:\n  Название приложения: gs_as, Платформа: as\n  Название приложения: hs_as, Платформа: as\nassert not [('gs_as', 'as'), ('hs_as', 'as')]","statusTrace":"setup = (<google.cloud.bigquery.client.Client object at 0x7f960ee326c0>, <environment.Environment object at 0x7f960e966900>)\n\n    @allure.story('Data_Tables_Creation')\n    @allure.severity(allure.severity_level.CRITICAL)\n    @allure.description(\"\"\"\n    Тест проверяет, что для всех app_name из таблицы app_names существует соответствие с app_short в таблице device_segments. Это гарантирует целостность данных между таблицами и правильность ссылок на приложения.\n    \"\"\")\n    def test_app_names_match(setup):\n        \"\"\"\n        Тест проверяет, что для всех app_name из таблицы app_names существует соответствие с app_short в таблице device_segments.\n        \"\"\"\n        bq_client, env = setup\n        app_names = env.get_full_table_id('app_names')\n        device_segments = env.get_full_table_id('device_segments')\n    \n        # Формирование SQL-запроса для проверки соответствия имен приложений\n        query = f\"\"\"\n            -- Выбираем уникальные названия приложений и платформы из таблицы app_names\n            SELECT DISTINCT an.app_name, an.platform\n            FROM `{app_names}` an\n            -- Условие для отбора записей, для которых не существует соответствующих записей в таблице device_segments\n            WHERE NOT EXISTS (\n              -- Подзапрос, который проверяет наличие записи в device_segments\n              SELECT 1\n              FROM `{device_segments}` ds\n              -- Условие соответствия между названием приложения и коротким названием приложения в таблице device_segments\n              WHERE an.app_name = ds.app_short AND an.platform = ds.platform\n            )\n        \"\"\"\n    \n        # Используем нашу вспомогательную функцию для выполнения запроса и логирования его в Allure.\n        results = execute_query_and_log(bq_client, query, \"Проверка соответствия названий приложений и платформ\",\n                                        include_query_in_message=True)\n    \n        # Сбор непрошедших проверку элементов\n        failed_items = [(row.app_name, row.platform) for row in results]\n    \n        with allure.step(\"Проверка на отсутствие непрошедших проверку элементов\"):\n>           assert not failed_items, \"Найдены приложения в app_names без соответствия в device_segments:\\n\" + \"\\n\".join(\n                f\"Название приложения: {app_name}, Платформа: {platform}\" for app_name, platform in failed_items)\nE           AssertionError: Найдены приложения в app_names без соответствия в device_segments:\nE             Название приложения: gs_as, Платформа: as\nE             Название приложения: hs_as, Платформа: as\nE           assert not [('gs_as', 'as'), ('hs_as', 'as')]\n\ntests/test_data_in_tables.py:83: AssertionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"setup","time":{"start":1712509334130,"stop":1712509334132,"duration":2},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"description":"\nТест проверяет, что для всех app_name из таблицы app_names существует соответствие с app_short в таблице device_segments. Это гарантирует целостность данных между таблицами и правильность ссылок на приложения.\n","status":"failed","statusMessage":"AssertionError: Найдены приложения в app_names без соответствия в device_segments:\n  Название приложения: gs_as, Платформа: as\n  Название приложения: hs_as, Платформа: as\nassert not [('gs_as', 'as'), ('hs_as', 'as')]","statusTrace":"setup = (<google.cloud.bigquery.client.Client object at 0x7f960ee326c0>, <environment.Environment object at 0x7f960e966900>)\n\n    @allure.story('Data_Tables_Creation')\n    @allure.severity(allure.severity_level.CRITICAL)\n    @allure.description(\"\"\"\n    Тест проверяет, что для всех app_name из таблицы app_names существует соответствие с app_short в таблице device_segments. Это гарантирует целостность данных между таблицами и правильность ссылок на приложения.\n    \"\"\")\n    def test_app_names_match(setup):\n        \"\"\"\n        Тест проверяет, что для всех app_name из таблицы app_names существует соответствие с app_short в таблице device_segments.\n        \"\"\"\n        bq_client, env = setup\n        app_names = env.get_full_table_id('app_names')\n        device_segments = env.get_full_table_id('device_segments')\n    \n        # Формирование SQL-запроса для проверки соответствия имен приложений\n        query = f\"\"\"\n            -- Выбираем уникальные названия приложений и платформы из таблицы app_names\n            SELECT DISTINCT an.app_name, an.platform\n            FROM `{app_names}` an\n            -- Условие для отбора записей, для которых не существует соответствующих записей в таблице device_segments\n            WHERE NOT EXISTS (\n              -- Подзапрос, который проверяет наличие записи в device_segments\n              SELECT 1\n              FROM `{device_segments}` ds\n              -- Условие соответствия между названием приложения и коротким названием приложения в таблице device_segments\n              WHERE an.app_name = ds.app_short AND an.platform = ds.platform\n            )\n        \"\"\"\n    \n        # Используем нашу вспомогательную функцию для выполнения запроса и логирования его в Allure.\n        results = execute_query_and_log(bq_client, query, \"Проверка соответствия названий приложений и платформ\",\n                                        include_query_in_message=True)\n    \n        # Сбор непрошедших проверку элементов\n        failed_items = [(row.app_name, row.platform) for row in results]\n    \n        with allure.step(\"Проверка на отсутствие непрошедших проверку элементов\"):\n>           assert not failed_items, \"Найдены приложения в app_names без соответствия в device_segments:\\n\" + \"\\n\".join(\n                f\"Название приложения: {app_name}, Платформа: {platform}\" for app_name, platform in failed_items)\nE           AssertionError: Найдены приложения в app_names без соответствия в device_segments:\nE             Название приложения: gs_as, Платформа: as\nE             Название приложения: hs_as, Платформа: as\nE           assert not [('gs_as', 'as'), ('hs_as', 'as')]\n\ntests/test_data_in_tables.py:83: AssertionError","steps":[{"name":"Проверка соответствия названий приложений и платформ\n\nExecuted query:\n\n        -- Выбираем уникальные названия приложений и платформы из таблицы app_names\n        SELECT DISTINCT an.app_name, an.platform\n        FROM `data-quality-project-1.dq_data_set.app_names` an\n        -- Условие для отбора записей, для которых не существует соответствующих записей в таблице device_segments\n        WHERE NOT EXISTS (\n          -- Подзапрос, который проверяет наличие записи в device_segments\n          SELECT 1\n          FROM `data-quality-project-1.dq_data_set.device_segments` ds\n          -- Условие соответствия между названием приложения и коротким названием приложения в таблице device_segments\n          WHERE an.app_name = ds.app_short AND an.platform = ds.platform\n        )\n    ","time":{"start":1712509335342,"stop":1712509336169,"duration":827},"status":"passed","steps":[],"attachments":[{"uid":"9f5031c74b63cc4e","name":"SQL Query","source":"9f5031c74b63cc4e.txt","type":"text/plain","size":958}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},{"name":"Проверка на отсутствие непрошедших проверку элементов","time":{"start":1712509336384,"stop":1712509336384,"duration":0},"status":"failed","statusMessage":"AssertionError: Найдены приложения в app_names без соответствия в device_segments:\n  Название приложения: gs_as, Платформа: as\n  Название приложения: hs_as, Платформа: as\nassert not [('gs_as', 'as'), ('hs_as', 'as')]\n","statusTrace":"  File \"/tests_project/tests/test_data_in_tables.py\", line 83, in test_app_names_match\n    assert not failed_items, \"Найдены приложения в app_names без соответствия в device_segments:\\n\" + \"\\n\".join(\n","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":0,"hasContent":true,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":2,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[],"labels":[{"name":"severity","value":"critical"},{"name":"story","value":"Data_Tables_Creation"},{"name":"parentSuite","value":"tests"},{"name":"suite","value":"test_data_in_tables"},{"name":"host","value":"0fcd2175af92"},{"name":"thread","value":"1-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_data_in_tables"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"critical","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":[]},"source":"d251892b8b34eba6.json","parameterValues":[]}